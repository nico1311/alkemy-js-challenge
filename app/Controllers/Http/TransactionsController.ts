import { HttpContextContract } from '@ioc:Adonis/Core/HttpContext';
import { rules, schema } from '@ioc:Adonis/Core/Validator';
import Transaction from 'App/Models/Transaction';

const TransactionTypes = {
  INCOME: 1,
  OUTCOME: 2
}

const OutcomeTransactionTypes = {
  NO_CATEGORY: 0,
  SHOPPING: 1,
  FOOD_AND_RESTAURANTS: 2,
  TRANSPORT: 3,
  EXPENSES_AND_SERVICES: 4,
  ENTERTAINMENT: 5,
  TRAVEL: 6
}

export default class TransactionsController {
  public async createTransaction(ctx: HttpContextContract) {
    const { auth, request, response } = ctx,
      user = auth.user!;

    const createTransactionPayloadSchema = schema.create({
      createdAt: schema.date.optional(),
      type: schema.enum(Object.values(TransactionTypes)),
      category: schema.enum.optional(Object.values(OutcomeTransactionTypes)),
      amount: schema.number(),
      comment: schema.string({}, [
        rules.maxLength(1000)
      ])
    });

    const transactionPayload = await request.validate({schema: createTransactionPayloadSchema});

    const transaction = await Transaction.create({
      ...transactionPayload,
      ...{
        userId: user.id
      }
    });

    // Since the timestamp might be generated by the database, fetch the row again
    await transaction.refresh();

    return response.status(201).send(transaction);
  }

  public async listTransactions(ctx: HttpContextContract) {
    const { auth, request, response } = ctx,
      user = auth.user!;

    const page = request.input('page', 1),
      itemsPerPage = request.input('limit', 10);

    const transactionsQuery = await Transaction.query()
      .where('userId', '=', user.id)
      .orderBy('created_at', 'desc')
      .paginate(page, itemsPerPage);

    if (transactionsQuery.length < 1) response.status(404);

    return transactionsQuery;
  }

  public async getTransaction(ctx: HttpContextContract) {
    const { auth, request, response } = ctx,
      user = auth.user!;
    const requestedId = request.param('id');

    const transaction = await Transaction.query()
      .where('id', '=', requestedId)
      .where('userId', '=', user.id)
      .first();

    if (!transaction) return response.status(404);

    return transaction;
  }

  public async editTransaction(ctx: HttpContextContract) {
    const { auth, request, response } = ctx,
      user = auth.user!;
    const requestedId = request.param('id');

    const transaction = await Transaction.query()
      .where('id', '=', requestedId)
      .where('userId', '=', user.id)
      .first();

    if (!transaction) return response.status(404);

    const editTransactionPayloadSchema = schema.create({
      createdAt: schema.date.optional(),
      category: schema.enum.optional(Object.values(OutcomeTransactionTypes)),
      amount: schema.number.optional(),
      comment: schema.string.optional({}, [
        rules.maxLength(1000)
      ])
    });

    const transactionPayload = await request.validate({schema: editTransactionPayloadSchema});

    for (const property in transactionPayload) {
      transaction[property] = transactionPayload[property];
    }

    await transaction.save();

    return response.status(200).send(transaction);
  }

  public async deleteTransaction(ctx: HttpContextContract) {
    const { auth, request, response } = ctx,
      user = auth.user!;
    const requestedId = request.param('id');

    const transaction = await Transaction.query()
      .where('id', '=', requestedId)
      .where('userId', '=', user.id)
      .first();

    if (!transaction) return response.status(404);

    await transaction.delete();

    return response.status(204);
  }
}
